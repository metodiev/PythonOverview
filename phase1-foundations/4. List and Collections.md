#4 — Lists and Collections
## Goal

Learn how to create, modify, and efficiently use lists, one of Python’s most versatile data structures.

## Concept

A list is an ordered, mutable collection of objects.
Lists can hold elements of different types, and you can modify them in place — add, remove, or reorder elements.

Lists are like dynamic arrays but with automatic resizing and rich built-in methods.

## List Basics

```bash
numbers = [10, 20, 30, 40]
mixed = [1, "two", 3.0, True]

print(numbers[0])    # 10
print(numbers[-1])   # 40 (last element)
print(numbers[1:3])  # [20, 30]
```
## List Operations

| Operation | Example              | Result                           |
| --------- | -------------------- | -------------------------------- |
| Append    | `lst.append(5)`      | Adds to end                      |
| Insert    | `lst.insert(1, "A")` | Inserts at index                 |
| Extend    | `lst.extend([6,7])`  | Concatenate another list         |
| Remove    | `lst.remove(20)`     | Removes first matching element   |
| Pop       | `lst.pop()`          | Removes and returns last element |
| Sort      | `lst.sort()`         | Sorts in place                   |
| Reverse   | `lst.reverse()`      | Reverses in place                |
| Length    | `len(lst)`           | Number of elements               |

## Examples

```bash
fruits = ["apple", "banana", "cherry"]
print(fruits)

fruits.append("date")
fruits.insert(1, "kiwi")
print(fruits)

fruits.remove("banana")
print(fruits)

last = fruits.pop()
print("Popped:", last)
print("Now:", fruits)

# Sorting and reversing
numbers = [4, 2, 9, 1]
numbers.sort()
print("Sorted:", numbers)
numbers.reverse()
print("Reversed:", numbers)
```


### Output:

```bash
['apple', 'banana', 'cherry']
['apple', 'kiwi', 'banana', 'cherry', 'date']
['apple', 'kiwi', 'cherry', 'date']
Popped: date
Now: ['apple', 'kiwi', 'cherry']
Sorted: [1, 2, 4, 9]
Reversed: [9, 4, 2, 1]
```

## List Comprehensions

A list comprehension is a compact way to create lists from existing iterables.

Example:
```bash
squares = [x**2 for x in range(5)]
print(squares)  # [0, 1, 4, 9, 16]
```

You can add conditions:
```bash
evens = [x for x in range(10) if x % 2 == 0]
print(evens)  # [0, 2, 4, 6, 8]
```

## Exercise

1. Create a list of 5 numbers.
2. Append two new numbers and remove one.
3. Sort the list in descending order.
4. Create a new list using list comprehension that contains only even numbers from it.
5. Print both lists.

## Reflection

- How does Python handle list resizing internally when you use .append() many times?
- What’s the difference between list.copy() and list = other_list?
- When should you use a list comprehension instead of a loop?


### Q1: How does Python handle list resizing internally when you use .append() many times?

Answer:
When you call .append(), Python doesn’t resize the list by one element each time — that would be too slow.
Instead, the list over-allocates memory so it can grow efficiently.

Here’s what happens internally:

The list stores a pointer to an array in memory.

When that array runs out of space, Python allocates a larger block, copies the elements, and continues.

The growth strategy is roughly geometric (it increases capacity by ~1.125x each time in CPython).

So .append() has amortized O(1) time complexity — it’s extremely efficient for dynamic growth.

## Q2: What’s the difference between list.copy() and list = other_list?

Answer:
list.copy() creates a new list object with the same elements.
list = other_list just creates a new reference (alias) to the same list in memory.

Example:
```bash
a = [1, 2, 3]
b = a          # same list
c = a.copy()   # new list

a.append(4)
print(b)  # [1, 2, 3, 4] — changes reflect
print(c)  # [1, 2, 3] — independent
```

In short:

- = → same object
- .copy() → shallow copy (new object, same contents)

## Q3: When should you use a list comprehension instead of a loop?

Answer:
Use list comprehensions when you can express a transformation or filtering operation in one clear line.

Example:
```bash
# Loop version
squares = []
for x in range(5):
    squares.append(x * x)

# Comprehension version
squares = [x * x for x in range(5)]
```

- List comprehensions are:
    - More concise and idiomatic
    - Often faster, since they run in C under the hood
    - Ideal for creating new lists, not for side effects
Use them when readability is preserved — avoid nesting multiple conditions or loops if it becomes confusing.

### Summary Takeaways

- Lists grow efficiently due to internal overallocation.
- .copy() prevents shared references — important for avoiding bugs.
- List comprehensions are the Pythonic way for creating new lists cleanly and fast.