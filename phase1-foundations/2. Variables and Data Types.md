#2: Variables and Data Types
## Goal

Understand how Python handles variables, dynamic typing, and the core data types.

## Concept

In Python, everything is an object, and variables are just references (names) to those objects.
There’s no need to declare types explicitly — Python infers them at runtime.
This makes experimenting fast but also requires mindfulness about mutability and type changes.

## Core Data Types
| Type    | Example                           | Description                 |
| ------- | --------------------------------- | --------------------------- |
| `int`   | `x = 10`                          | Whole numbers               |
| `float` | `pi = 3.14`                       | Decimal numbers             |
| `str`   | `name = "Alice"`                  | Text (Unicode)              |
| `bool`  | `is_ready = True`                 | Boolean values              |
| `list`  | `nums = [1, 2, 3]`                | Ordered, mutable sequence   |
| `tuple` | `coords = (10, 20)`               | Ordered, immutable sequence |
| `dict`  | `user = {"id": 1, "name": "Bob"}` | Key-value mapping           |
| `set`   | `tags = {"python", "ai"}`         | Unordered unique values     |

## Example

```python
x = 10
y = 3.5
name = "Alice"
is_ready = True

items = [1, 2, 3]
point = (4, 5)
config = {"debug": True, "version": 1.0}
tags = {"python", "learning"}

print(type(x), type(items), type(config))

```
Output:
```bash
<class 'int'> <class 'list'> <class 'dict'>
```
## Exercise

Create 5 variables of different types: integer, float, string, list, and dict.

Print each variable and its type using print(type(...)).

Modify one list and one dict, and print them again to see how they change.

## Reflection

What happens if you assign a new value of a different type to the same variable (e.g., x = "Hello")?

How does Python’s dynamic typing feel compared to static typing?

What kind of bugs could this flexibility introduce?


### Q1: What happens if you assign a new value of a different type to the same variable (e.g., x = "Hello")?

 Answer:
Python simply rebinds the name to a new object of the new type.
Variables are just labels that point to objects in memory — the label doesn’t “own” the type.

Example:
```bash
x = 10      # x → int(10)
x = "Hello" # x → str("Hello")
```

The integer 10 still exists in memory (until garbage collected), but x now points to a string object.
This dynamic rebinding is why Python is called dynamically typed.

### Q2: How does Python’s dynamic typing feel compared to static typing?

Answer:
Dynamic typing feels flexible and fast for prototyping, since you don’t have to define types upfront.
However, it can lead to runtime errors if variable types change unexpectedly.

For example:

total = 10
total += "5"  # TypeError at runtime


A static language like Java would catch that during compilation.
That’s why professional Python projects often use type hints and mypy to get static-like checks while keeping flexibility.

### Q3: What kind of bugs could this flexibility introduce?

Answer:
Dynamic typing can hide subtle logical or data bugs:

Accidentally reassigning a variable to a different type:
```bash
count = 5
count = "five"  # later math breaks
```

Functions returning different types depending on logic:
```bash
def get_id(flag):
    if flag: return 10
    else: return "10"  # inconsistent type
```

Mutable default arguments being reused between calls (common Python pitfall).
