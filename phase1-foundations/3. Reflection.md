# Reflection 

## Q1: What happens if you try to modify a character directly, e.g. s[0] = "X"?

Answer:
You’ll get an error:

TypeError: 'str' object does not support item assignment

Strings in Python are immutable, meaning once created, their contents cannot change.
To “modify” a string, you must create a new one.



Example:
```bash
s = "python"
s = "P" + s[1:]  # creates a new string
print(s)  # "Python"
```
So, every transformation — like .replace() or .upper() — returns a new string object, not a modified one.

## Q2: Why does Python make strings immutable?

Answer:

- Immutability offers several advantages:
- Safety: Strings are used as dictionary keys and in sets — immutability ensures their hash value never changes.
- Performance: Immutable objects can be shared and cached (e.g., string interning).
- Predictability: No function can accidentally modify your string in place.
- This design decision keeps Python programs simpler and safer when handling text data.

## Q3: Compare .format() vs. f-strings — which feels more natural?
 Answer:
f-strings (introduced in Python 3.6) are more concise, readable, and faster.

Example:
```bash
name = "Alice"
age = 30

# Older style
print("Name: {}, Age: {}".format(name, age))

# f-string style
print(f"Name: {name}, Age: {age}")

```
F-strings are evaluated at runtime, allowing direct expression embedding:
```bash
print(f"Next year: {age + 1}")
```

In practice, f-strings have become the standard way to format strings — both cleaner and more expressive.

## Summary of Key Takeaways

- Strings are immutable → every change creates a new string.
- Immutability improves safety and efficiency.
- F-strings are now the Pythonic choice for formatting.