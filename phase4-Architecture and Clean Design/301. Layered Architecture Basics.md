# Layered Architecture Basics
## Goal

Learn how to structure a Python project using layered architecture for maintainability and separation of concerns.

## Concept

Layered architecture organizes code into distinct layers, each with a clear responsibility:

    - Domain layer – Core business logic and entities.
    - Service layer – Orchestrates business operations, applies rules.
    - Adapter layer (or interface) – Handles external communication (CLI, API, DB).

This separation improves:

Testability
Maintainability
Modularity

## Example Structure

```bash
domain.py

class User:
    def __init__(self, username, email):
        self.username = username
        self.email = email

```

```bash
service.py

from domain import User

class UserService:
    def __init__(self):
        self.users = []

    def create_user(self, username, email):
        user = User(username, email)
        self.users.append(user)
        return user
```


```bash
adapter_cli.py

from service import UserService

def main():
    service = UserService()
    user = service.create_user("alice", "alice@example.com")
    print(f"User created: {user.username} ({user.email})")

if __name__ == "__main__":
    main()
```

Output:

User created: alice (alice@example.com)

## Exercise

- Create a Product entity in the domain layer with name and price.
- Implement a ProductService with methods add_product and list_products.
- Write a simple CLI adapter that adds a few products and prints them.
- Reflect on what would happen if you mixed domain logic into the CLI adapter.

Reflection

- Why is it better to separate domain logic from service/adapters?
- How would layered architecture help if you later add a REST API or database?
- Can you spot any potential drawbacks of too many layers?